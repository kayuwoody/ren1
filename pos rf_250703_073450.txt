/* Refactored Coffee POS Codebase
This document consolidates all necessary changes to move to a Woo-first, clientId-filtered workflow. Apply these file-by-file to your existing project. */
// 1. lib/orderService.ts import WooCommerceRestApi from "@woocommerce/woocommerce-rest-api";
const api = new WooCommerceRestApi({ url: process.env.WC_STORE_URL, consumerKey: process.env.WC_CONSUMER_KEY, consumerSecret: process.env.WC_CONSUMER_SECRET, version: 'wc/v3', });
export async function createWooOrder(payload: any) { const { data } = await api.post('orders', payload); return data; }
export async function updateWooOrder(id: number, payload: any) { const { data } = await api.put(orders/${id}, payload); return data; }
export async function findProcessingOrder(clientId: string) { const { data } = await api.get('orders', { status: 'processing', meta_key: 'clientId', meta_value: clientId, per_page: 1, }); return data[0] || null; }
export async function listWooOrders() { const { data } = await api.get('orders', { per_page: 100 }); return data; }
export async function getWooOrder(id: number) { const { data } = await api.get(orders/${id}); return data; }
// 2. app/api/create-order/route.ts export const runtime = 'nodejs'; import { NextResponse } from 'next/server'; import { createWooOrder } from '@/lib/orderService';
export async function POST(req: Request) { try { const body = await req.json(); const order = await createWooOrder(body); return NextResponse.json(order); } catch (err: any) { console.error('Error creating Woo order:', err); return NextResponse.json({ error: err.message }, { status: 500 }); } }
// 3. app/api/update-order/[orderId]/route.ts export const runtime = 'nodejs'; import { NextResponse } from 'next/server'; import { updateWooOrder } from '@/lib/orderService';
export async function POST(req: Request, { params }: any) { const id = Number(params.orderId); try { const body = await req.json(); const order = await updateWooOrder(id, body); return NextResponse.json(order); } catch (err: any) { console.error('Error updating Woo order:', err); return NextResponse.json({ error: err.message }, { status: 500 }); } }
// 4. app/api/orders/processing/route.ts export const runtime = 'nodejs'; import { NextResponse } from 'next/server'; import { findProcessingOrder } from '@/lib/orderService';
export async function GET(req: Request) { const clientId = req.nextUrl.searchParams.get('clientId') || ''; if (!clientId) return NextResponse.json(null); try { const order = await findProcessingOrder(clientId); return NextResponse.json(order); } catch (err: any) { console.error('Error finding processing order:', err); return NextResponse.json({ error: err.message }, { status: 500 }); } }
// 5. app/api/orders/route.ts export const runtime = 'nodejs'; import { NextResponse } from 'next/server'; import { listWooOrders } from '@/lib/orderService';
export async function GET() { try { const orders = await listWooOrders(); return NextResponse.json(orders); } catch (err: any) { console.error('Error listing Woo orders:', err); return NextResponse.json({ error: err.message }, { status: 500 }); } }
// 6. app/api/orders/[orderId]/route.ts export const runtime = 'nodejs'; import { NextResponse } from 'next/server'; import { getWooOrder } from '@/lib/orderService';
export async function GET(req: Request, { params }: any) { const id = Number(params.orderId); try { const order = await getWooOrder(id); return NextResponse.json(order); } catch (err: any) { console.error('Error fetching Woo order:', err); return NextResponse.json({ error: err.message }, { status: 500 }); } }
// 7. app/checkout/page.tsx (patched) "use client"; import React from 'react'; import { useCart } from '@/context/cartContext'; import { useRouter } from 'next/navigation';
export default function CheckoutPage() { const { cartItems, clearCart } = useCart(); const router = useRouter();
const handleConfirm = async () => { let clientId = localStorage.getItem('clientId'); if (!clientId) { clientId = crypto.randomUUID(); localStorage.setItem('clientId', clientId); } const processingRes = await fetch( /api/orders/processing?clientId=${clientId} ); const existing = await processingRes.json();
const transformed = cartItems.map(i => ({ product_id: i.id, quantity: i.quantity, })); let wooOrder; if (existing && existing.id) { const upd = await fetch(`/api/update-order/${existing.id}`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ line_items: transformed }), }); wooOrder = await upd.json(); } else { const crt = await fetch(`/api/create-order`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ line_items: transformed, set_paid: true, meta_data: [{ key: 'clientId', value: clientId }], }), }); wooOrder = await crt.json(); } localStorage.setItem('currentOrderId', String(wooOrder.id)); const start = Date.now(); const total = cartItems.reduce((s, i) => s + i.quantity, 0); localStorage.setItem('startTime', String(start)); localStorage.setItem( 'endTime', String(start + total * 2 * 60 * 1000) ); clearCart(); router.push(`/orders/${wooOrder.id}`); 
};
return ( Checkout {cartItems.map(item => ( {item.name} ×{item.quantity} ${(item.price * item.quantity).toFixed(2)} ))} <button onClick={handleConfirm} disabled={cartItems.length === 0} className="w-full bg-blue-600 text-white py-2 rounded disabled:opacity-50" > {cartItems.length === 0 ? 'Cart is empty' : 'Confirm & Pay'} ); }
// 8. app/orders/page.tsx (list) "use client"; import React, { useEffect, useState } from 'react'; import Link from 'next/link';
export default function OrdersPage() { const [orders, setOrders] = useState<any[]>([]); const clientId = localStorage.getItem('clientId') || '';
useEffect(() => { fetch('/api/orders') .then(res => res.json()) .then(all => { // filter/sort const mine = all.filter(o => o.meta_data.some(m=>m.key==='clientId'&&m.value===clientId)); const processing = mine.filter(o=>o.status==='processing'); const rest = all .filter(o=>!(processing.some(p=>p.id===o.id))) .sort((a,b)=> new Date(b.date_created).getTime() - new Date(a.date_created).getTime()); setOrders([...processing, ...rest]); }); }, []);
return ( All Orders {orders.length===0 ? ( No orders yet. ) : ( {orders.map(o => ( <li key={o.id} className={p-2 rounded ${o.status==='processing'?'bg-yellow-100':'bg-gray-100'}}> <Link href={/orders/${o.id}}>Order {o.id} — {o.status} ))} )} ); }
// 9. app/orders/[orderId]/page.tsx (detail) "use client"; import React, { useEffect, useState } from 'react'; import { useRouter } from 'next/navigation'; import QRCode from 'react-qr-code'; import { CircularProgressbar } from 'react-circular-progressbar'; import 'react-circular-progressbar/dist/styles.css';
export default function OrderDetailPage({ params }: any) { const orderId = params.orderId; const [order, setOrder] = useState(null); const [progress, setProgress] = useState(0);
const start = Number(localStorage.getItem('startTime')); const end = Number(localStorage.getItem('endTime'));
useEffect(() => { const fetchOrder = async () => { try { const res = await fetch(/api/orders/${orderId}); const data = await res.json(); setOrder(data); } catch (_){/.../} }; fetchOrder(); const iv = setInterval(fetchOrder, 10000); return () => clearInterval(iv); }, [orderId]);
useEffect(() => { if (order?.status === 'processing') { const tick = () => { const now = Date.now(); const pct = Math.min(1,(now-start)/(end-start)); setProgress(pct*100); }; tick(); const iv = setInterval(tick,1000); return () => clearInterval(iv); } else if (order?.status==='ready-to-pickup') { setProgress(100); } }, [order]);
if (!order) return Loading…;
return ( Order {order.id} <div style={{width:100,height:100,margin:'auto'}}> <CircularProgressbar value={progress} text={${Math.round(progress)}%} /> Status: {order.status} {order.status==='ready-to-pickup' && ( <QRCode value={order.meta_data.find(m=>m.key==='qr_payload')?.value || ''} /> Locker: {order.meta_data.find(m=>m.key==='locker_number')?.value} )} ); }
// 10. components/HeaderNav.tsx "use client"; import React, { useEffect, useState } from 'react'; import Link from 'next/link'; import { ShoppingCart, Clock } from 'lucide-react'; import { useCart } from '@/context/cartContext';
export default function HeaderNav() { const { cartItems } = useCart(); const [hasProcessing, setHasProcessing] = useState(false); const [currentOrderId, setCurrentOrderId] = useState<string | null>(null);
useEffect(() => { const id = localStorage.getItem('currentOrderId'); setCurrentOrderId(id); const clientId = localStorage.getItem('clientId') || ''; fetch(/api/orders/processing?clientId=${clientId}) .then(r=>r.json()) .then(o=> setHasProcessing(!!o?.id)); }, []);
return ( Home Products Orders {cartItems.length>0 && ({cartItems.length})} {hasProcessing && currentOrderId && ( <Link href={/orders/${currentOrderId}}> )} ); }
// End of refactor.